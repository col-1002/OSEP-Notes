# 1. Intro
`C#` (pronounced "C sharp") is a general-purpose, object-oriented programming (OOP) language developed by Microsoft within its `.NET` initiative. It is fundamentally rooted in the C and C++ family of languages and borrows aspects from Java, making C# very familiar for developers of those languages.

Hello world in
##### C `#`

```csharp
using System;
class Program
{
    static void Main(string[] args)
    {
        Console.WriteLine("Hello, World!");
    }
}
```

##### C++

```cpp
#include <iostream>
int main()
{
    std::cout << "Hello, World!";
    return 0;
}
```

##### Java

```java
public class Main
{
    public static void main(String[] args)
    {
        System.out.println("Hello, World!");
    }
}
```

## Next
The C# project commenced in the late 1990s, known initially as `Cool`, an acronym for "C-like Object Oriented Language". The driving force for the project was to build a language that offered the computational power of C++ combined with the simplicity of Visual Basic. Its key designer was Anders Hejlsberg, a prominent engineer previously involved in designing Turbo Pascal and Delphi at Borland, who still serves as the lead architect of C#.

C# was officially announced in July 2000, with the release of .NET Framework 1.0 following in 2002. C# is one of several languages that can be used to build .NET applications but by far the most dominant. Other languages can be used with the .NET Framework, such as Visual Basic and F#.

The `.NET Framework` is a language-agnostic software development and runtime platform developed by Microsoft. It provides a controlled environment for developing and running applications. Programs written for the .NET Framework execute in a software environment known as the `Common Language Runtime` (CLR), an application virtual machine that provides services such as security, memory management, and exception handling. There are many different components to the .NET Framework; some are listed below:

- The `Common Language Runtime (CLR)` is the execution engine for .NET Framework applications. It provides various services, such as memory management and thread management.
- The `.NET Framework Class Library (FCL)` is a standard library that encapsulates many common functions, such as file reading and writing, graphic rendering, database interaction, and XML document manipulation.
- `Common Language Specification (CLS)` is a set of rules and standards that enforce language interoperability.
- `Common Type System (CTS)` is a standard that defines all possible data types and programming constructs supported by CLR and how they interact.

### JIT

Just-In-Time compilation, or `JIT`, is a significant component of runtime environments in many modern programming languages, such as Java, Python with PyPy, LUA with LuaJIT and the .NET languages like C#. Programming Languages broadly fall into two categories: `Interpreted languages` and `compiled languages`, and a JIT compiler straddles the divide between the two.

A `statically compiled` language compiles (translates) the source code to machine code before execution. In this machine code format, the compiled binary represents the instruction set that a CPU interprets and executes. This approach offers more optimised performance than interpretation because the translation is done beforehand. However, static compilation requires additional development time due to the compile-link-execute cycle, and the resulting binaries are platform-specific.

In contrast, source code is not directly translated to machine code in an `interpreted language`. Instead, a separate program called the interpreter reads and executes the source code instructions. While this simplifies the development process because no compilation and linking steps are necessary, it can lead to slower execution speed because the interpretation needs to be performed as the program runs.

Just-In-Time compilation aims to combine the benefits of both `interpretation` and `static compilation`. It translates the source code into an intermediate form, akin to bytecode, a portable, platform-independent code. The bytecode is closer to machine code than the high-level source code but is not tied to a specific hardware configuration.

The bytecode is translated to machine code when the program is executed, but not in one big chunk. Instead, the translation happens just in time (hence the name), i.e., right before each portion of the code is executed. This strategy of deferred compilation aims to avoid the overhead of compiling parts of the program that are never executed during a particular run.

A JIT compiler is part of the `Common Language Runtime` (`CLR`). Instead of building machine code during compilation, .NET compiles into an intermediate language called the Microsoft Common Intermediate Language (MSIL or CIL). The processor then executes this machine code. The CLR maintains a cache of compiled methods during the program's execution. If a method is called more than once, the CLR can skip the JIT compilation step on subsequent calls and use the previously compiled machine code, resulting in performance improvements.

It's worth noting that there is a trade-off in JIT compilation between startup time and execution speed. JIT compilation can slow program start-up because the initial compilation to machine code happens during runtime. However, once the program runs, execution can be very fast—often comparable to statically compiled code.

### .NET Core and .NET

Microsoft introduced `.NET Core` as a successor to the .NET Framework, addressing many of the limitations and concerns with the .NET Framework, such as it is Windows-specific and not compatible with other platforms. .NET Core is a cross-platform framework designed for building modern, cloud-based, and internet-connected applications. It runs on Windows, Linux, and macOS, making it a suitable choice for developers aiming for wide compatibility. .NET Core comprises `CoreCLR`, a complete runtime, and `CoreFX`, a library built to run apps. It was first released in June 2016.

In 2020, Microsoft announced it was consolidating its .NET offerings into a single .NET platform. This marked the birth of `.NET 5`, which aimed to unify the .NET Framework and .NET Core. The unification process was designed to take the best from .NET Core, .NET Framework, Xamarin, and Mono to build a single platform for all .NET applications. The shift aimed to provide a single .NET runtime and framework that can be used everywhere, further strengthening the .NET platform's versatility and robustness.

The advent of .NET 5 and its successors (.NET 6, 7, 8 and beyond) has ushered in an era where developers no longer have to pick and choose different .NET technologies for different types of applications. Instead, they can use a unified platform for all their work, reducing the complexity of building and deploying .NET applications.

One of the key features of .NET 5 and later versions is their support for a broad spectrum of application types, including web applications, desktop applications, cloud services, IoT applications, machine learning, and more.

Furthermore, .NET 5 and its successors follow a `release schedule` with updates every November. Microsoft has committed to long-term support (LTS) releases every two years, ensuring stability and support for developers who prefer not to update their .NET runtime and libraries annually.

## What is C# used for

C# is a versatile and powerful programming language that can be employed to construct various program types to fulfil diverse needs and requirements. Here is a snapshot of the broad range of applications you can build with C#:

1. `Console Applications`: Perfect for building command-line interfaces, these applications are text-driven, devoid of graphical user interfaces (GUIs), and ideal for crafting simple utilities or scripts.
2. `Windows Forms Applications (WinForms)`: These GUI desktop applications come packed with a rich set of controls, including text boxes, labels, and buttons.
3. `Windows Presentation Foundation (WPF) Applications`: WPF offers a framework for creating sophisticated desktop applications with advanced UI features such as graphics, multimedia, and animations.
4. `Universal Windows Platform (UWP) Applications`: UWP apps are designed to provide a universal experience across Windows 10, Windows 10 Mobile, Windows 11, Xbox One, Xbox Series X/S, and HoloLens.
5. `Xamarin Applications`: Xamarin provides a platform for crafting mobile applications operable on multiple platforms, including iOS, Android, and Windows, all from a unified C# codebase.
6. `.NET Multi-platform App UI (MAUI) Applications`: MAUI is the evolution of `Xamarin`, extending from mobile to desktop. It allows for creating cross-platform Android, iOS, macOS, and Windows applications with a single codebase. Using MAUI, developers can create flexible and high-performance native applications using .NET and C#.
7. `ASP.NET Applications`: ASP.NET is a robust framework for building dynamic web applications, capable of serving web pages, RESTful APIs, real-time services, and more.
8. `Web Services`: These applications, accessible over standard web protocols like HTTP, SOAP, and REST, facilitate communication between applications over the Internet.
9. `Class Libraries`: These encompass collections of classes and other types that can be utilised by different applications, supporting code reuse and modular design.
10. `Unity Games`: Unity is a widely-used game development platform, with C# employed for scripting game behaviour.

## Installing the DevEnv

Visual Studio (VS) and VSCode are the most common IDEs for C# development. 
- VS -> Install the `.NET Desktop Developer` meta package.
- VS Code: URL [Download](https://code.visualstudio.com/Download) the version suitable for your OS -> Run -> Follow the instructions

### .NET

There are a few ways to install `.NET`. Regardless of what platform you install -> [Install .NET on Windows, Linux, and macOS](https://learn.microsoft.com/en-us/dotnet/core/install/)

```powershell
E:\HTB_Academy\HTB_CWEE_source_code\Intro_to_C_Sharp> dotnet --version

7.0.401
```

This command will output the version of .NET installed on your machine => successful install.

C# can also be utilised in a manner similar to interpreted languages, like Python, with tools such as [LINQPad](https://www.linqpad.net/) or [CSharpRepl](https://github.com/waf/CSharpRepl). Furthermore, extensions are available that enable a Jupyter-like [notebook experience in VSCode](https://marketplace.visualstudio.com/items?itemName=ms-dotnettools.dotnet-interactive-vscode) or a kernel extension to [use .NET in Jupyter](https://github.com/dotnet/interactive/blob/main/docs/NotebookswithJupyter.md) directly.

### .NET CLI

We will interact with `dotnet` via a console more than anything, as Visual Studio Code does not have the same level of 'hands-off tooling' that a full IDE, such as Visual Studio, provides. Below is a breakdown of some of the important commands to know:

- `dotnet new`: Creates a new .NET project. You can specify the type of project (`console`, `classlib`, `webapi`, `mvc`, etc.). For example, `dotnet new console` will create a new console application.
- `dotnet build`: Builds a .NET project and all of its dependencies. The `-c` or `--configuration` option can be used to specify the build configuration (`Debug` or `Release`).
- `dotnet run`: Builds and runs the .NET project. It is typically used during the development process to run the application for testing or debugging purposes.
- `dotnet test`: Runs unit tests in a .NET project using a test framework such as `MSTest`, `NUnit`, or `xUnit`.
- `dotnet publish`: Packs the application and its dependencies into a folder for deployment to a hosting system. The `-r` or `--runtime` option can be used to specify the target runtime.
- `dotnet add package`: Adds a NuGet package reference to the project file. You specify the package by name. For example, `dotnet add package Newtonsoft.Json`.
- `dotnet remove package`: Removes a NuGet package reference from the project file. Similar to the `add package` command, you specify the package to remove by name.
- `dotnet restore`: Restores the dependencies and tools of a project. This command is implicitly run when you run `dotnet new`, `dotnet build`, `dotnet run`, `dotnet test`, `dotnet publish`, and `dotnet pack`.
- `dotnet clean`: Cleans the output of a project. This command is typically used before you build the project again, as it deletes all the previously compiled files, ensuring that you start from a clean state.
- `dotnet --info`: Displays detailed information about the installed .NET environment, including installed versions and all runtime environments.

### A template quirk

We will use the Console template for running all code in this module

```csharp
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Basic_Console_App_2
{
    internal class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Hello world!");
        }
    }
}

```

# 2. Basic syntax
The C# syntax refers to the rules governing how programs written in the C# language are structured. These rules dictate aspects such as how variables are declared or initialised and how loops or conditional statements are written. This set of rules constitutes the language’s grammar and is at the core of crafting valid and efficient C# programs.

Let's delve into several essential elements of C# syntax:
#### 1. Main Method

In C#, any application begins its execution from a special method known as `Main`. This is the entry point of any C# application. When the application starts, the `Main` method is the first invoked method. The C# compiler will show an error if the `Main` method is absent.

The `Main` method can be located inside any class in the C# project; however, placing it within a class named `Program` is standard practice.

```csharp
class Program
{
    public static void Main() { }
    public static int Main() { }
    public static int Main(string[] args) { }
    public static async Task Main() { }
    public static async Task<int> Main() { }
    public static async Task Main(string[] args) { }
    public static async Task<int> Main(string[] args) { }
    public static void Main(string[] args)
    {
        // Program execution starts here
    }
}
```

#### 2. Case Sensitivity

In C#, case sensitivity is a fundamental aspect of the language syntax. This means the language differentiates between uppercase and lowercase characters, treating them as distinct. As a result, identifiers named with different cases are considered separate entities by the C# compiler.

For instance, consider the following variable declarations:

```csharp
int myVariable = 10;
int MyVariable = 20;
```

*This feature extends to all areas of the language, including class names, method names, and other identifiers.*

It's essential to be consistent with case when defining and using identifiers in C#.
#### 3. Identifiers

In C#, an identifier is a name assigned to a variable, method, function, or any user-defined item. It is essentially a way to refer to a code component for use in operations, functions, and algorithms.

There are a few rules and conventions to bear in mind when creating identifiers in C#:

1. An identifier must start with a letter or an underscore character (`_`). For example, `variable`, `_variable` are valid identifiers but `1variable` is not.
2. After the first character, it can have a series of alphanumeric characters (letters and digits) and an underscore (`_`).
3. Reserved words in C# cannot be used as identifiers. For example, you cannot use `int` or `while` as an identifier because they have predefined uses in C#.
4. There's no strict limit on the length of an identifier in C#, but it's advisable to keep them reasonably short to maintain readability.

```csharp
int score;
string playerName;
float _temperature;
```

#### 4. Keywords

C# includes a set of reserved words known as keywords, which have predefined meanings in the language's syntax. Examples of keywords include `public`, `class`, `void`, `if`, `else`, `while`, etc. Keywords cannot be used as identifiers.

```csharp
class MyClass { ... }
if (condition) { ... }
```

#### 5. The ;

The semicolon (`;`) is known as a `statement terminator` in C#. It's employed to signify the end of a specific statement or command in the code. Using the semicolon as a statement terminator is common in many programming languages, including `C++`, `Java`, and `JavaScript`.

```csharp
int x = 10;  // The semicolon terminates the variable declaration statement.

Console.WriteLine(x);  // The semicolon terminates the method call statement.

x++;  // The semicolon terminates the increment operation.
```

By correctly terminating each statement, the compiler can discern where one command ends and the next begins. Neglecting to include a semicolon at the end of a statement often results in compile-time errors.

#### 6. Statements & Expressions

A statement in C# represents a complete command to perform a specific action.

An expression, on the other hand, is a combination of operands (variables, literals, method calls, etc.) and operators (`+, -, *, /, %, etc.`) that can be evaluated to a single value.

```csharp
int sum = 10 + 20; // This line is a statement
10 + 20; // This is an expression
```

#### 7. Blocks of Code

Blocks in C# are sections of code enclosed in braces (`{ }`). They are typically used to group multiple statements together to form a single executable unit, such as the body of a method, loop, or conditional statement.

```csharp
if (number > 5)
{
    Console.WriteLine("The number is greater than 5");
    number--;
}
```

#### 8. Comments

Comments in C# are used to add explanatory notes in the source code. Single-line comments begin with two forward slashes (`//`), and multi-line comments are enclosed between `/* and */`. The C# compiler ignores comments.

```csharp
// This is a single-line comment

/* This is a 
   multi-line 
   comment */
```

#### 9. Read Compiler Errors

The C# compiler provides incredible verbosity with its error messages. Don't just discard the output as "Oh no, it's an error"; it will contain valuable information, generally indicating the root problem.

A typical C# compiler error message has three parts:

```bash
/tmp/X/Program.cs(5,21): error CS0029: Cannot implicitly convert type 'string' to 'int'
```

1. `Error Location`: This tells you where in your code the error occurred, typically indicated by a line number and a character position.
2. `Error Code`: This alphanumeric code uniquely identifies the error type. It is helpful when looking up additional information about the error.
3. `Error Description`: This part of the message describes the error in plain English. It provides insights into what rule was violated in the code.


---
# 3. Understanding Variables, Constants, and Data Types
In C#, as with any programming language, you must handle and manipulate data. To do this, you work with variables and constants which store values and represent different data types. Understanding how to use variables, constants, and data types correctly and effectively is fundamental to programming.
#### Variables

A variable in C# is a name given to a storage area in memory, with the value stored being changeable. Variables are defined by two key properties: a name and a data type.

The name, or identifier, of a variable, is how you refer to the stored data within your code. Variable names in C# can consist of letters, numbers, and underscores, but they must always start with a letter or an underscore.

The data type of a variable determines what kind of data the variable can store. To declare a variable in C#, you first specify the data type, followed by the variable name:



```csharp
int myNumber;
```

You can also assign a value to the variable at the time of declaration:



```csharp
int myNumber = 10;
```

#### Constants

A constant in C# is similar to a variable in that it's a name given to a storage area in memory. However, the value of a constant, as the name implies, remains constant throughout the program; once it's been set, it cannot be changed.

To declare a constant in C#, you use the `const` keyword, followed by the data type, the constant name, and an assignment to set the constant's value:



```csharp
const int myConstant = 10;
```

C# will throw an error if you trying to modify a constant. Constants can be helpful when you use a value repeatedly throughout your code and know it will not change.

#### Enums

`Enums`, or enumerations, are a special type of value type in C#. They are particularly useful for representing a distinct set of named constants, providing a more human-readable form for a specific set of integral values.



```csharp
public enum DayOfWeek 
{
    Sunday,
    Monday,
    Tuesday,
    Wednesday,
    Thursday,
    Friday,
    Saturday
}
```

In this case, `DayOfWeek` is an `enum` that represents the seven days of the week. Each day is an enumerator. By default, the first enumerator has the value 0, and the value of each successive enumerator is increased by 1. You can also specify the underlying integral type and assign specific values to the enumerators, like so:



```csharp
public enum Month : byte
{
    January = 1,
    February = 2,
    // And so on...
}
```

Here, `Month` is an `enum` with an underlying type of `byte`, and each month is explicitly assigned a value representing its position in the year.

You can use `enums` in your code to make it more readable and safer, as it limits the possible values you can assign.



```csharp
DayOfWeek today = DayOfWeek.Monday;
```

This clearly indicates that the variable `today` can only hold one of the seven days of the week. Trying to assign it any other value will result in a compile-time error.

#### Data Types

Understanding the different data types, their characteristics, and their appropriate use is crucial in C#. Each data type serves a specific purpose, and choosing the right one can influence your code's functionality and efficiency. Here's a closer look at the primary data types in C#:

Integer Types are used to store whole numbers without decimal points. There are several integer types in C#, each of which can store a different range of values:



```csharp
byte aByte = 255; // Range: 0 to 255
sbyte aSbyte = -128; // Range: -128 to 127
short aShort = -32768; // Range: -32,768 to 32,767
ushort aUshort = 65535; // Range: 0 to 65,535
int anInt = -2147483648; // Range: -2,147,483,648 to 2,147,483,647
uint aUint = 4294967295; // Range: 0 to 4,294,967,295
long aLong = -9223372036854775808; // Range: -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807
ulong aUlong = 18446744073709551615; // Range: 0 to 18,446,744,073,709,551,615
```

Floating Point Types are used to store numbers with decimal points. They include the `float` and `double` types:



```csharp
float aFloat = 3.1415927f; // Range: ±1.5 x 10^-45 to ±3.4 x 10^38, Precision: 7 digits
double aDouble = 3.141592653589793; // Range: ±5.0 x 10^-324 to ±1.7 x 10^308, Precision: 15-16 digits
```

The Decimal Type is used for large or small decimal numbers and for financial and monetary calculations where precision is critical.



```csharp
decimal aDecimal = 3.14159265358979323846m; // Range: ±1.0 x 10^-28 to ±7.9 x 10^28, Precision: 28-29 digits
```

The Boolean Type is a logical data type with two values, `true` or `false`.



```csharp
bool aBool = true; // or false
```

The Character Type is used to store a single Unicode character.



```csharp
char aChar = 'C'; // Can be a letter, a number, a symbol, or a special character like a newline (`\n`) or a tab (`\t`)
```

The String Type is used to store a sequence of characters or text.



```csharp
string aString = "Hello, World!";
```

In rare scenarios, you might not know the variable type at compile time. For such cases, C# provides a special type called `var`. The `var` keyword instructs the compiler to infer the variable type from the expression on the right side of the initialisation statement. The compiler then assigns the most appropriate type.



```csharp
var number = 10; // The compiler will infer that 'number' is an integer
var message = "Hello, World!"; // Here, 'message' is inferred as a string
```

It's important to note that `var` can only be used when a variable is declared and initialised simultaneously. Once a variable is declared with `var` and initialised, its type cannot be changed; it remains strongly typed.



```csharp
var myVariable = 10;
myVariable = "Hello"; // This will cause a compile error
```

In this example, even though we used `var` for declaration, the compiler inferred `myVariable` to be of type `int` because it was initialised with an integer. So, trying to assign a string value to it later in the code results in a compile-time error.

Using `var` can make your code cleaner and easier to read, particularly when dealing with complex types such as generics or anonymous types. However, overuse of `var` can make your code harder to understand, as it's unclear what type each variable is. Use it sparingly.

In addition to these types, C# also supports Nullable Types, which can represent the normal range of values for its underlying value type, plus an additional null value. These are explained more on the next page.



```csharp
int? nullableInt = null;
```

---
# 4. Operators and Type conversion
## OPERATORS

Operators are an integral part of any programming language, enabling specific operations between operands, thus allowing the creation of complex expressions and conditions. C# offers many operators: arithmetic, relational, logical, bitwise, assignment, unary, ternary, and null conditional.

#### Arithmetic Operators

In C#, these operators enable mathematical operations. They include `+` (addition), `-` (subtraction), `*` (multiplication), `/` (division), and `%` (modulus, which gives the remainder of a division).

```csharp
int a = 10;
int b = 5;

int sum = a + b; // Result: 15
int difference = a - b; // Result: 5
int product = a * b; // Result: 50
int quotient = a / b; // Result: 2
int remainder = a % b; // Result: 0
```

#### Relational Operators

These compare two values and determine the relationship between them. C# includes `==` (equal to), `!=` (not equal to), `>` (greater than), `<` (less than), `>=` (greater than or equal to), and `<=` (less than or equal to).

```csharp
int a = 10;
int b = 20;

bool isEqual = (a == b); // Result: false
bool isNotEqual = (a != b); // Result: true
bool isGreaterThan = (a > b); // Result: false
bool isLessThan = (a < b); // Result: true
bool isGreaterThanOrEqualTo = (a >= b); // Result: false
bool isLessThanOrEqualTo = (a <= b); // Result: true
```

#### Logical Operators

These operators use Boolean (`true` or `false`) values to create logical expressions. C# provides `&&` (logical AND), `||` (logical OR), and `!` (logical NOT).

```csharp
bool isTrue = true;
bool isFalse = false;

bool andResult = isTrue && isFalse; // Result: false
bool orResult = isTrue || isFalse; // Result: true
bool notResult = !isTrue; // Result: false
```

#### Bitwise Operators

Bitwise operators are useful when working with binary data, which is common in fields such as cryptography or image processing where you need to manipulate individual bits within a block of data. Bitwise Operators offer a level of precision that is impossible with conventional arithmetic or logical operators.

They include `&` (bitwise AND), `|` (bitwise OR), `^` (bitwise XOR), `~` (bitwise NOT), `<<` (left shift), and `>>` (right shift).

|Operator|Description|
|---|---|
|`&` (bitwise AND)|Compares each bit of the first operand to the corresponding bit of the second operand. If both bits are 1, the corresponding result bit is set to 1. Otherwise, the result bit is set to 0.|
|\| (bitwise OR)|Compares each bit of the first operand to the corresponding bit of the second operand. If either bit is 1, the corresponding result bit is set to 1. If both bits are 0, the result bit is set to 0.|
|`^` (bitwise XOR)|Compares each bit of the first operand to the corresponding bit of the second operand. If the bits are not identical, the corresponding result bit is set to 1. If they are identical, the result bit is set to 0.|
|`~` (bitwise NOT)|Flips the bits of its operand. If a bit is 0, it becomes 1; if a bit is 1, it becomes 0.|
|`<<` (left shift)|Moves the bits of the operand to the left by the number of places specified by the second operand. Bits that are shifted off the left are discarded, and zeros are shifted in on the right.|
|`>>` (right shift)|Moves the bits of the operand to the right by the number of places specified by the second operand. Bits that are shifted off the right are discarded, and zeros are shifted in on the left.|

```csharp
int a = 240; // Binary: 1111 0000
int b = 15; // Binary: 0000 1111

int andResult = a & b; // Result would be 0, Binary: 0000 0000
int orResult = a | b; // Result would be 255, Binary: 1111 1111
int xorResult = a ^ b; // Result would be 255, Binary: 1111 1111
int notResult = ~a; // Result would be -241, Binary: 0000 1111
int leftShift = a << 2; // Result would be 960, Binary: 11 1100 0000
int rightShift = a >> 2; // Result would be 60, Binary: 0011 1100
```

#### Assignment Operators

C# includes `=` (simple assignment), and compound assignment operators like `+=`, `-=`, `*=`, `/=`, and `%=`, which combine an arithmetic operation with assignment.

```csharp
int a = 10; // simple assignment

a += 5; // equivalent to a = a + 5, so a now is 15
a -= 3; // equivalent to a = a - 3, so a now is 12
a *= 2; // equivalent to a = a * 2, so a now is 24
a /= 4; // equivalent to a = a / 4, so a now is 6
a %= 5; // equivalent to a = a % 5, so a now is 1
```

#### Unary Operators

Unary operators are those that operate on a single operand. They include `++` (increment), `--` (decrement), `+` (unary plus, denotes positive values), and `-` (unary minus, denotes negative values). Unary operators also include the `!` logical negation operator mentioned earlier.

```csharp
int a = 5;
a++; // Now a is 6
a--; // Now a is 5 again
int b = +a; // b is 5
int c = -a; // c is -5
```

#### Ternary Operator

Ternary operators provide a shorthand way of writing an `if-else` condition. The syntax is `condition ? true expression : false expression`. `if-else` and other control flow statements are explained in `Control Statements and Loops`.

```csharp
int a = 10;
int b = 20;

// expanded if-else
if (a > b)
{
    result = "a is greater";
}
else
{
    result = "b is greater";
}

// contracted ternary
string result = a > b ? "a is greater" : "b is greater";
//In this case, because `a` is not greater than `b`, the result would be `"b is greater"`.
```

#### Null Conditional Operators

These operators, introduced in C# 6.0, are used to access members and elements of an object safely. They return `null` if the object is `null` instead of throwing a `NullReferenceException`.

There are two null conditional operators:

1. `Null Conditional Member Access (?.)`: facilitates the safe access of an object's members, including properties or methods. As depicted in your second example, the Length property of the `authorName` string is being accessed. If `authorName` is `null`, a `NullReferenceException` will not be thrown. Instead, it will simply yield `null`.
2. `Null Conditional Element Access (?[])`: utilised to secure access to array or collection elements. When the array or collection is `null`, using `?[]` to access an element won't result in an exception. Rather, it will return `null`. For instance, in your first example, as `authors` is `null`, `authors?[0]` consequently returns `null`.

```csharp
string[] authors = null;
var author1 = authors?[0]; // This will not throw an exception even though authors is null. author1 will simply be null.

string authorName = null;
int? length = authorName?.Length; // Again, this will not throw an exception. length will be null.
```

In both cases, if the objects (`authors` and `authorName`) were not null, the respective indices and properties would be accessed normally. However, since they are null, the operators prevent a `NullReferenceException` and return `null`. These operators have significantly enhanced how developers handle null references in C#, providing a more compact and streamlined way to ensure safe access to members of potentially null objects.

#### Null-coalescing Operator

In C#, the null-coalescing operator is a binary operator that simplifies checking for null values. It is represented by a double question mark `??`.

The null-coalescing operator returns the value of its left-hand operand if it is not null; otherwise, it evaluates the right-hand operand and returns its result.

```csharp
int? x = null;
int y = x ?? -1;
```

Since `x` is null, the value `-1` is assigned to `y` in this example.

This operator is particularly useful for providing default values when a variable is null. Without the null-coalescing operator, you would need to use an `if` statement to check for null values:

```csharp
int? x = null;
int y;

if (x != null)
    y = x.Value;
else
    y = -1;
```

As you can see, using the null-coalescing operator `??` makes the code much more concise and easier to read. You can also use the null-coalescing assignment operator `??=`. This operator assigns the value of its right-hand operand to its left-hand operand only if the left-hand operand evaluates to null:

```csharp
int? x = null;
x ??= -1;  // x is now -1 because it was null
```

## Type Conversion

In programming, especially in a statically typed language like C#, it is often necessary to convert data from one type to another. This could be because an operation requires a certain data type, or you need to interact with an API that expects a different one. This process is called type conversion, and there are two types of conversions in C#: implicit and explicit.

**Implicit Type Conversion (or Widening Conversion)**

The compiler performs These conversions *automatically* without the programmer's intervention. They happen when converting a smaller type to a larger type (like `int` to `long` or `float`), or a derived class to its base. These conversions are safe and do not lead to data loss.

```csharp
int numInt = 10;
long numLong = numInt; // Implicit conversion from int to long
```

**Explicit Type Conversion (or Narrowing Conversion)**

The programmer performs These conversions *manually* using predefined functions. Explicit conversions require a cast operator. They happen when converting a larger type to a smaller type (like `long` to `int`) or a base class to its derived. These conversions can lead to data loss or a `System.OverflowException`.

```csharp
double numDouble = 10.5;
int numInt = (int)numDouble; // Explicit conversion from double to int. numInt will be 10, the fractional part is lost
```

C# also supports built-in methods for converting types, particularly from/to string types, like `ToString()`, `ToInt32()`, `ToDouble()`, etc., which are part of the `Convert` class.

```csharp
int numInt = 10;
string str = numInt.ToString(); // Converts numInt to a string
int num = Convert.ToInt32(str); // Converts str back to an integer
```

## Type Checking

C# provides operators to check the type of an object: the `is` operator and the `as` operator.

- **is**: It checks whether an object is compatible with a given type, and the result of the operation is `bool`.

```csharp
string str = "Hello, World!";
bool result = str is string; // result will be true
```

- **as**: It is used for casting between compatible reference types or nullable types. If the cast fails, it returns `null` instead of throwing an exception.

```csharp
object obj = new string("Hello, World!");
string str = obj as string; // str will be "Hello, World!" if the cast is successful; otherwise, it will be null
```


---
# 5. Namespaces
In C#, a namespace is a way to group related code elements into logical units, such as `classes`, `interfaces`, `enums`, and more. Namespaces provide organisation and help avoid naming conflicts by creating a `hierarchical structure` for code. They serve as `containers` for `organising and categorising code elements`, making managing and maintaining large codebases easier. Namespaces also enable code reuse and `promote modularity` by clearly `separating concerns`.

The primary purposes of namespaces are twofold:

1. `Organization`: Namespaces systematically organise code elements based on their functionality or domain. They help developers locate and navigate code more efficiently, enhancing code readability and maintainability
2. `Avoiding Naming Conflicts`: Namespaces prevent naming conflicts by providing a unique context for code elements. Code elements within a namespace are distinguished by their fully qualified names, which include the namespace name as a prefix. This ensures that code elements with the same name coexist within different namespaces.

Namespaces exist in other languages too: Java, Python, JavaScript (ES6), C++

#### Creating and Organizing Code

To create a namespace in C#, use the `namespace` keyword followed by the name. Code elements, such as classes, etc., are defined within the namespace.

```csharp
namespace MyNamespace
{
    class MyClass
    {
        // Class implementation
    }

    interface IMyInterface
    {
        // Interface implementation
    }
}
```

The above example defines a namespace named `MyNamespace`, containing the `MyClass` class and the `IMyInterface` interface. There are a few points to keep in mind when implementing namespaces:

1. `Group-Related Functionality`: Place code elements closely related in the same namespace. This ensures that code with similar functionality is grouped, making it easier to locate and understand.
    
2. `Avoid Over-Nesting`: Keep the namespace hierarchy concise and avoid excessive nesting. Deeply nested namespaces can lead to long, complex names hindering code readability.
    
3. `Follow a Logical Structure`: Create a logical structure for your namespaces that aligns with your project's architecture or module organisation. Consider using a naming convention that reflects the organisation of your codebase.

#### Importing and Using

You have two options to use code elements from a namespace in a C# program: either fully qualify the code element's name with the namespace, or import the namespace via the `using` directive.

```csharp
using System;

namespace MyNamespace
{
    class Program
    {
        static void Main()
        {
            // Using a fully qualified name
            System.Console.WriteLine("Hello, World!");

            // Using the imported namespace
            Console.WriteLine("Hello, World!");
        }
    }
}
```

In the above example, the `System` namespace is imported using the `using` directive. This allows us to use `Console.WriteLine()` directly without fully qualifying it with the `System` namespace.

*Importing namespaces using the `using` directive can significantly reduce code verbosity and improve readability. However, avoiding unnecessary or excessive importing of namespaces is important to prevent potential naming conflicts or confusion.*

#### Resolving Naming Conflicts

A naming conflict occurs when multiple namespaces define code elements with the same name. C# provides ways to resolve such conflicts to ensure unambiguous access to code elements.

To resolve naming conflicts, you can use one of the following approaches:

1. `Fully Qualify the Code Element`: Use the fully qualified name of the code element, including the namespace, to ensure explicit identification.

```csharp
namespace MyNamespace
{
    class MyClass { }

    class Program
    {
        static void Main()
        {
            // Using fully qualified name to avoid naming conflict
            MyNamespace.MyClass myObject = new MyNamespace.MyClass();
        }
    }
}
```

2. `Alias the Namespace`: When importing, use an alias to differentiate between conflicting namespaces. This provides a shorthand way to refer to the code elements without ambiguity.

```csharp
using MyAlias = MyNamespace;
using AnotherAlias = AnotherNamespace;

namespace MyNamespace
{
    class MyClass { }
}

namespace AnotherNamespace
{
    class MyClass { }

    class Program
    {
        static void Main()
        {
            // Using aliases to differentiate between conflicting namespaces
            MyAlias.MyClass myObject1 = new MyAlias.MyClass();
            AnotherAlias.MyClass myObject2 = new AnotherAlias.MyClass();
        }
    }
}
```

---
# 6. Console I/O
Console applications run in a console window (aka CLI) instead of a GUI. In a console application, users interact with the program by entering commands as text, and the program responds with text-based output. The `Console` class provides methods and properties to interact with the console. These include functionalities such as reading from and writing to the console, changing the colour of the console text and background, changing the title of the console window, and altering the size and position of the console window, among others.

#### Console.Read

The `Console.Read` method is utilised for reading a *single character* from the standard input stream, which is typically the keyboard. The primary feature of this method is that it blocks the current thread of execution until a character is available. This effectively pauses the program, awaiting user input.

When the user inputs a character and presses the enter key, `Console.Read` retrieves the ASCII value of the character and returns it as an integer. If the end of the input stream has been reached, this method will return -1.

```csharp
Console.Write("Please press a key: ");
int input = Console.Read();
Console.WriteLine("You pressed: " + (char)input);

// is used to capture the user's key presss and output to console.
```


#### Console.ReadLine

=> is designed to read an entire line of input from the standard input stream. Unlike `Console.Read`, which reads a single character, `Console.ReadLine` captures all characters input by the user until they press the enter key.

Upon pressing the enter key, `Console.ReadLine` returns the captured input as a string. If no further lines are available (i.e., the end of the input stream is reached), the method will return null.

```csharp
Console.Write("Please enter your name: ");
string name = Console.ReadLine();
Console.WriteLine("Hello, " + name);

// This captures the user's name as a string. The program then greets the user using the provided name.
```


#### Console.Write

The `Console.Write` method is a fundamental mechanism for displaying output to the console in C#. It is designed to write the specified string value to the standard output stream, typically the console window. This method does not append a trailing newline character to the output. As a consequence, any subsequent calls to `Console.Write` or `Console.WriteLine` will continue on the same line in the console.

It's important to note that `Console.Write` can handle other data types in addition to strings. It accomplishes this by automatically invoking the `ToString` method on the provided argument, converting it to a string before output.

```csharp
Console.Write("Pi is approximately "); // The first `Console.Write` call outputs a string
Console.Write(3.14159); // `ToString()` method is implicitly called to convert the number into a string for display.
```


#### Console.WriteLine

The `Console.WriteLine` method behaves very similarly to `Console.Write`, with one key distinction: it automatically appends a newline character (`\n`) after the output. This has the effect of moving the cursor to the beginning of the next line in the console. Therefore, any subsequent `Console.Write` or `Console.WriteLine` calls will start outputting on a new line.

```csharp
Console.WriteLine("Hello, World!");
Console.WriteLine("Today's date is " + DateTime.Now.ToShortDateString());
```

In this example, the first `Console.WriteLine` call outputs a greeting and moves the cursor to the next line. The second call outputs a string concatenated with today's date, obtained via `DateTime.Now.ToShortDateString()` and converted to a string via implicit use of `ToString`.


# Shortcut key

![[Pasted image 20240518180335.png]]


.